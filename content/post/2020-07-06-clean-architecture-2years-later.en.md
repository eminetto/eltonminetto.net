+++
title = "Clean Architecture, 2 years later"
subtitle = ""
date = "2020-07-06T10:54:24+02:00"
bigimg = ""

+++
In February 2018 I wrote what would become the most relevant text I have ever published: [Clean Architecture using Golang](https://eltonminetto.dev/en/post/2018-03-05-clean-architecture-using-go/). With more than 105k views, the post generated presentations at some Go and PHP events and allowed me to talk about software architecture with several people. 

Using this architecture for the development of [Codenation](https://codenation.dev)'s products, we gained experience and solved problems. We wrote some posts reporting these experiences:

- [Golang: using build tags to store configurations](https://eltonminetto.dev/en/post/2018-06-25-golang-usando-build-tags/)
- [Continuous integration in projects using monorepo](https://eltonminetto.dev/en/post/2018-08-01-monorepo-drone/)
- [Monitoring a Golang application with Supervisor](https://eltonminetto.dev/en/post/2018-11-28-monitorando-app-go-com-supervisor/)
- [Data Migration with Golang and MongoDB](https://eltonminetto.dev/en/post/2019-01-23-migracao-de-dados-com-go-e-mongodb/)
- [Using Golang as a scripting language](https://eltonminetto.dev/en/post/2019-08-08-golang-linguagem-script/)
- [Creating test mocks using GoMock](https://eltonminetto.dev/en/post/2019-12-19-gomock/)
- [Using Prometheus to collect metrics from Golang applications](https://eltonminetto.dev/en/post/2020-03-13-golang-prometheus/)
- [Profiling Golang applications using pprof](https://eltonminetto.dev/en/post/2020-04-08-golang-pprof/)
- [Testing APIs in Golang using apitest](https://eltonminetto.dev/en/post/2020-04-21-golang-apitest/)

After this whole experience I can say::

> Choosing Clean Architecture was the best technical decision we made!

With this post, I want to share a [repository](https://github.com/eminetto/clean-architecture-go-v2) with a new example implementation in Go. It is an update with improvements in the organization of codes and directories, as well as a more complete example for those who are looking to implement this architecture.

In the next topics, I explain what each directory means.

## Entity layer

Let's start with the innermost layer of the architecture.

According to [Uncle Bob's post](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html):

> Entities encapsulate *Enterprise wide* business rules. An entity can be an object with methods, or it can be a set of data structures and functions. It doesnâ€™t matter so long as the entities could be used by many different applications in the enterprise.

The structure looked like this:

[![entity](/images/posts/1-entity_book.png)](/images/posts/1-entity_book.png)

In this package, we have the definition of the entity (`entity.go`) and the interfaces of the `Repository` and `Manager` (in `interface.go`). The `Manager` will use a `Repository` to perform basic operations on the entity, such as the famous `CRUD`. 

We also have the implementations of the repository in `MySQL` (`repository_mysql.go`) and in-memory (`repository_inmem.go`), as well as the implementation of the `Manager` interface (in `manager.go`).

We also found the `mocks` generated by `Gomock`, as explained in this [post](https://eltonminetto.dev/en/post/2019-12-19-gomock/). The other layers of the architecture will use this mocks during the tests.



## Use Case Layer

According to Uncle Bob::

> The software in this layer contains application specific business rules. It encapsulates and implements all of the use cases of the system

The structure looked like this:

[![domain](/images/posts/2-domain_loan.png)](/images/posts/2-domain_loan.png)

In packages within `domain/usecase` we implement the business rules for our product. According to the definition of the architecture, these `UseCases` make use of the entities and the `Managers` that deal with them. It is also possible to see the existence of mocks, as the previous layer.


## Controller layer

In this application, there are two ways to access the `UseCases`. The first is through an `API` and the second is using a command line application (`CLI`).

The `CLI`'s structure is very simple:

[![cli](/images/posts/4-cmd.png)](/images/posts/4-cmd.png)

It makes use of domain packages to perform a book search:

```go
dataSourceName := fmt.Sprintf("%s:%s@tcp(%s:3306)/%s?parseTime=true", config.DB_USER, config.DB_PASSWORD, config.DB_HOST, config.DB_DATABASE)
db, err := sql.Open("mysql", dataSourceName)
if err != nil {
  log.Fatal(err.Error())
}
defer db.Close()
repo := book.NewMySQLRepository(db)
manager := book.NewManager(repo)
all, err := manager.Search(query)
if err != nil {
  log.Fatal(err)
}
for _, j := range all {
  fmt.Printf("%s %s \n", j.Title, j.Author)
}
```	

In the example above, you can see the use of the `config` package. You can see its structure below, and more details in this [post](https://eltonminetto.dev/post/2018-06-25-golang-usando-build-tags/). 

[![config](/images/posts/3-config.png)](/images/posts/3-config.png)

The `API` structure is more complex, with three packages: `handler`, `presenter`, and `middleware`.

The `handler` package handle `HTTP` `requests` and `responses`, as well as using existing business rules in the `domain`.

[![handler](/images/posts/5-handler.png)](/images/posts/5-handler.png)

The `presenters` are responsible for formatting the data generated as a `response` by `handlers`.


[![presenter](/images/posts/6-presenter.png)](/images/posts/6-presenter.png)


In this way, the entity `User`:

```go
type User struct {
   ID        entity.ID
   Email     string
   Password  string
   FirstName string
   LastName  string
   CreatedAt time.Time
   UpdatedAt time.Time
   Books     []entity.ID
}
```

It can be transformed into:

```go
type User struct {
   ID        entity.ID `json:"id"`
   Email     string    `json:"email"`
   FirstName string    `json:"first_name"`
   LastName  string    `json:"last_name"`
}
```

This gives us control over how an entity will be delivered via the `API`.

In the last package of the `API` we find the `middlewares`, used by several `endpoints`:

[![middlware](/images/posts/7-middleware.png)](/images/posts/7-middleware.png)

## Support packages

They are packages that provide common functionality such as encryption, logging, file handling, etc. These features are not part of the domain of our application, and all the layers can use them. Even other applications can import and use these packages.

[![pkg](/images/posts/8-pkg.png)](/images/posts/8-pkg.png)

The [README.md](https://github.com/eminetto/clean-architecture-go-v2) contains more details, such as instructions for compilation and usage examples.

My goals with this post to strengthen my recommendation on this architecture and also to receive feedback about the codes. 

If you want to learn how to use this architecture in your favorite programming language, you could use this repository as an example of this learning. That way, we can have different implementations, in different languages, to ease the comparison.

Special thanks to my friend [Gustavo Schirmer](https://twitter.com/hurrycaner)  who gave great feedbacks on the text and the codes.